---
title: 'Results across platforms'
author: "Selene Fregosi"
date: "`r format(Sys.time(), '%d %B %Y')`"
geometry: margin = 1cm
output:
  html_document:
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "",
  prompt = FALSE,
  fig.width = 10,
  fig.height = 10
)
```

Created following https://taikisan21.github.io/PAMpal/banterGuide.html

## Setup

```{r libraries, eval=T, message=FALSE}

library(banter)
library(rfPermute)
library(tidyverse)
```

```{r set_paths}

path_models <- file.path('T:/fregosi/cross_platform_banter_big_data/models')

```


## Load towed array model

```{r load-ta}
modelFile <- file.path(path_models,  'bantMDL_HICEAS2017-CH5_Filtered_577_2024-05-20.rdata')

load(modelFile)

bant.rf <- getBanterModel(bant.mdl)
bantData.df <- getBanterModelData(bant.mdl)

bant.mdl_ta <- bant.mdl


```


### 2.4 Interpret _BANTER_ Results
The `summary()` function provides information regarding your model results; however, conducting a 'deep dive' into these results will give you a better understanding of the strengths and limitations of your results and may guide you towards improving those results. Here we demonstrate a number of options for interpreting your _BANTER_ results. 

#### 2.4.1 Model Information

**Detector Names & Sample Sizes**  
Show the Detector Names and Sample Sizes
```{r, include=TRUE}
# Get detector names for your _BANTER_ Model
getDetectorNames(bant.mdl)
# Get Sample sizes
getSampSize(bant.mdl)
```

**Number of Calls & Events, Proportion of Calls**  
Number of calls (`numCalls()`), proportion of calls (`propCalls()`) and number of events (`numEvents()`) in your _BANTER_ detector models (or specify by event/species)
```{r, include=TRUE}
# number of calls in detector model
numCalls(bant.mdl)
# number of calls by species (can also do by event)
numCalls(bant.mdl, "species")

# proportion of calls in detector model
propCalls(bant.mdl)
# proportion of calls by event (can also do by species)
#propCalls(bant.mdl, "event")
#[this is commented out as printout is long]

# number of events, with default for Event Model
numEvents(bant.mdl)
# number of events for a specific detector 
numEvents(bant.mdl, "Whistle_and_Moan_Detector")
```

#### 2.4.2 Random Forest Summaries

The following functions are available in the `rfPermute` package and take a `randomForest` or `rfPermute` model object. Recall from above that the actual `randomForest` object can be extracted from the _BANTER_ model with the `getBanterModel()` function.

**Confusion Matrix**  
The Confusion Matrix is the most commonly used output for a Random Forest model, and is provided by `summary()`. The output includes the percent correctly classified for each species, the lower and upper confidence levels, and the priors (expected classification rate). 

By default, `summary()` reports the 95% confidence levels of the percent correctly classified. By using the `confusionMatrix()` function, we can specify a different confidence level if desired. However, unlike `summary()`, `confusionMatrix()` takes a `randomForest` object like the one we extracted above.
```{r, include=TRUE}
# Confusion Matrix
confusionMatrix(bant.rf, conf.level = 0.75)
```
The `confusionMatrix()` function also has a `threshold` argument that provides the binomial probability that the true classification probability (given infinite data) is greater than or equal to this value. For example, if we want to know what the probability is that the true classification probability for each species is >= 0.80, we set `threshold = 0.8`:
```{r, include=TRUE}
# Confusion Matrix with medium threshold
confusionMatrix(bant.rf, threshold = 0.8)
```
This shows that _D. capensis_ has a high probability of having a true classification score above 0.8 (Pr.gt_0.8 = 79.0). Conversely, the probability that the classification rate for _D.delphis_ is above 0.8 is very low (Pr.gt_0.8 = 6.8).  

And alternative view of the confusion matrix comes in the form of a heat map.
```{r, include=TRUE}
# Plot Confusion Matrix Heatmap
plotConfMat(bant.rf, title="Confusion Matrix HeatMap") 
```

We can also examine confusion matrices for individual detectors, such as the whistle detector ("Whistle_and_Moan_Detector"):
```{r}
wmd.rf <- getBanterModel(bant.mdl, "Whistle_and_Moan_Detector")
confusionMatrix(wmd.rf)
plotConfMat(wmd.rf) 
```

**Model Percent Correct**  
This function operates on a _BANTER_ model object and provides a summary data frame with the percent of each species correctly classified for each detector model and the event model. It is a summary of the diagonal values from the confusion matrices for all models.
```{r, include=TRUE}
modelPctCorrect(bant.mdl)
```

**Plot Votes**  
The strength of a classification model depends on the number of trees that 'voted' for the correct species. We can look at the votes from each of these 5,000 trees for an event to see how many of them were correct. This plot shows these votes where each vertical slice is an event, and the percentage of votes for each species is represented by their color. If all events for a species were to be correctly classified by all of the trees (votes) in the forest, then the plot for that species would be solid in the color that represents that species. 
```{r, include=TRUE, fig.width = 10, fig.asp = 0.6}
# Plot Vote distribution
plotVotes(bant.rf) 
```

**Percent Correct**  
Another way to visualize this distribution is to evaluate the percent of events correctly classified for a given threshold (specified percent of trees in the forest voting for that species). 
```{r, include=TRUE}
# Percent Correct for a series of thresholds
pctCorrect(bant.rf, pct = c(0.8, 0.6, .05))
```
These values will always decrease as the percent of trees threshold increases. That is because as stringency is decreased (lower thresholds), more samples are likely to be correctly classified. These values give an indication of the fraction of events that can be classified with high certainty. As we can see in this example data, the distribution goes to zero for all species at 95%. That is there are no events in any species that are correctly classified with 95% certainty.  

**Plot Predicted Probabilities**  
The full distribution of assignment probabilities to the predicted species class can be visualized with the `plotPredictedProbs()` function in `rfPermute`. Ideally, all events would be classified to the correct species (identified by the color), and would be strongly classified to the correct species (higher probablity of assignment). This plot can be used to understand the distribution of these classifications, and how strong the misclassifications were, by species.
```{r, include=TRUE, fig.width = 10, fig.asp = 0.6}
plotPredictedProbs(bant.rf, bins = 30, plot = TRUE)
```

**Proximity Plot**  
The proximity plot provides a visualization of the distribution of events within the tree space. It shows the relative distance of events based on their average distance in nodes in the trees across the forest. For each event in the plot, the color of the central dot represents the true species identity, and the color of the circle represents the _BANTER_ classification. Ideally, these would form rather distinct clusters, one for each species. The wider the spread of the events in this feature space, the more variation found in these predictors. Some species differentiation may be predicted by other predictors and may not be clear based on this pair of dimensions (those may be differentiated with different predictors). 
```{r, include=TRUE, fig.width = 10}
# Proximity Plot
plotProximity(bant.rf)
```

**Importance Heat Map**  
The importance heat map provides a visual assessment of the important predictors for the overall model. The _BANTER_ event model relies on the mean assignment probability for each of the detectors in our detector model, as well as any event level measures. For example, in this heat map, the first variable is  'dw.D.delphis', which is the mean probability that a detection was assigned to the species 'D.delphis' in the whistle detector. This requires extra steps to dig down to the specific whistle measures that are the important predictor variables for the whistle detector. 
```{r, include=TRUE}
# Importance Heat Map
plotImportance(bant.rf, plot.type = "heatmap")
```

#### 2.4.3 Mis-Classified Events

By segregating the misclassified events, you can dive deeper into these data to understand why the model failed. Perhaps they were incorrectly classified in the first place (inaccurate training data) or the misclassification could be due to natural variability in the call characteristics. There are any number of possibilities, and by diving into the misclassifications, you can learn a lot about your data and your model. We do not recommend eliminating misclassifications simply because they are misclassifications. The point is to learn more about your data, not to cherry pick your data to get the best performing model.  

**Case Predictions** 
If it is important to identify only strong classification results, they can be identified and filtered using the `casePredictions()` function in `rfPermute`.
```{r, include=TRUE}
casePredict <- casePredictions(bant.rf)
head(casePredict)
```

This function returns a data frame with the original and predicted species for each event along with if the event was correctly classified and the assignment probabilities to each species.  
To identify misclassified events, we just filter this data frame and grab the original event id.
```{r, include=TRUE}
misclass <- casePredict %>% 
  filter(!is.correct) %>%
  select(id)

casePredict[casePredict$id %in% misclass$id,]
```

We can then look closer at these events to learn more about them.

#### 2.4.4 Variable Importance

One of the powerful features of Random Forest is the ability to assess and rank which predictors are important to the classification model. These values are based on measures of how much worse the classifier performs when the predictor variables are randomly permuted. The `importance()` function in the `randomForest` package extracts these values from a `randomForest` object.
```{r, include=TRUE}
# Get importance scores and convert to a data frame
bant.imp <- data.frame(importance(bant.rf))
head(bant.imp)
```

To see the actual distribution of these values in each species, we can first identify the most important predictors (highest importance scores)
```{r, include=TRUE}
# Select top 4 important event stage predictors
bant.4imp <- bant.imp[order(bant.imp$MeanDecreaseAccuracy, decreasing = TRUE), ][1:4, ]
bant.4imp
```

The predictors that showed the greatest importance came from the whistle (dw) detector and the burst pulse (bp) detectors. We can then plot the distribution of the predictor variables on these classes (in this case, a violin plot for each of these four most important variables). 

```{r}
plotImpPreds(bant.rf, bantData.df, "species", max.vars = 4)
```


### 2.5 Predict
The goal of building an acoustic classifier is to ultimately apply this classifier to novel data. It is critical to understand that we should apply our _BANTER_ classifier to data collected in the same manner. All variables (detectors, detector measures, event-level variables) must also be the same (with the same labels). For example, novel data collected using a different hydrophone with different sensitivity curves may result in different measurements from your original model (unless the data is calibrated). Even in the case where a classifier is applied to the appropriate data, it is wise to validate a subset of this novel data.  

To run a prediction model, you must have your _BANTER_ model, and new data. Here we will use the `bant.mdl` object we made previously, and apply it to the `test.data` provided in the _BANTER_ package.  

**Predict**
The `predict()` function will apply your _BANTER_ model to novel data and provide you with a data frame with the events used in the Event Model for predictions, and a data frame of predicted species and assignment probabilities for each event.  
The`predict()` function will ignore any _a priori_ species designation in the event and detection data, so this can be specified if it is desired to compare model predictions with other identifications, or left un-specified.
```{r, include=TRUE}
# data(test.data)
# predict(bant.mdl, test.data)
```


